// Author: Carter Roberts
// Institution: Loyola University New Orleans
// Instructor: Dr. Omar EL Khatib
// Filename: bnf.cpp
// Description: bnf syntax checker for parser function for language implementation
// Date Created (MM/DD/YYYY): 9/10/2025
// Date Modified (MM/DD/YYYY): 9/10/2025

#include <iostream>
using namespace std;

void expr();
void term();
void factor();

// expr
// Parses strings in the language generated by the rule:
// <expr> -> <term> {(+ | -) <term>}
void expr() {
    // Parse the first term
    term();
    // As long as the next token is + or -, get
    // the next token and parse the next term
    while (nextToken == ADD_OP || nextToken == SUB_OP) {
        lex();
        term();
    }
}

// term
// Parses strings in the language generated by the rule:
// <term> -> <factor> {(* | /) <factor>)
void term() {
    // Parse the first factor
    factor();
    // As long as the next token is * or /, get the
    // next token and parse the next factor 
    while (nextToken == MUL_OP || nextToken == DIV_OP) {
        lex();
        factor();
    }
}

// factor
// Parses strings in the language generated by the rule:
// <factor> -> <ident> | <int_literal> | <float_literal> | ( <expr> )
void factor() {
    // Determine which RHS
    if (nextToken == VAR || nextToken == INT_LIT)
        lex(); // Get the next token
    else { // token is not identifier, integer literal or float literal
    if (nextToken == LEFT_PAREN) { // left paraenthsis founf
        lex(); // get next token
        expr(); // parse expression
        if (nextToken == RIGHT_PAREN) lex(); // right paraenthsis found, get next token
        else errMsg("Right parenthesis expected, found " + lexeme);
    } // End-if (nextToken == LEFT_PAREN
    else errMsg("expected var, integer literal, or left parenthesis, found " + lexeme);
    }
}

// assign - parse assignment statement by the rule:
// <assign> -> <identifier> = <expr>
void assign() {
    if (nextToken == VAR) { // identifier found
        if (!search_symbol(lexeme)) // if lexeme is not in symbol table
            errMsg("Undefined variable " + lexeme);
        lex();
        if (nextToken == ASSIGN_OP) { // equal sign found
            lex(); // get next token
            expr(); // parse expression
        }
        else errMsg ("equal sign expected, found " + lexeme);
    }
    else errMsg("Variable expected, found " + lexeme);
}

// <intVar> - parse integer variable by the rule:
// <intVar> -> <ident> | <ident><intLit>
void initializeVar() {
    string varName = lexeme;
    lex();
    if (nextToken == ASSIGN_OP) {
        lex(); // get next token
        if (nextToken == INT_LIT) {
            int value = atoi(lexeme.c_str()); // convert string to integer
            add_symbol(varName, value); // add variable to the symbol table
            lex();
        }
        else errMsg("Integer initialization expected, found " + lexeme);
    }
    else add_symbol(varName, 0);
}

// int_ident - integer identifier (variable) parser by the rule:
// <intIdent> -> <intVar> <intVar>*
void intVar() {
    if (nextToken == VAR) {
        while (nextToken == VAR) {
            initializeVar();
            if (nextToken == COMMA) lex();
            else break;
        }
    }
    else errMsg("Variable expected, fount " + lexeme);
}

// decl - parse declaration statement by the rule
// <ident> -> int <intIdent> | float <floatIdent>
void declaration() {
    lex(); // variable token expected
    intVar();
}

// stmt - statement parser by the rule:
// <stmt> -> <decl> | <assign>
void stmt() {
    if (nextToken == INT_KEYWORD) declaration(); // parse declaration
    else assign(); // parse assignment statement
}