// Author: Carter Roberts
// Institution: Loyola University New Orleans
// Instructor: Dr. Omar EL Khatib
// Filename: q2Parser.cpp
// Description: 2nd parser function for language implementation
// Date Created (MM/DD/YYYY): 9/22/2025
// Date Modified (MM/DD/YYYY): 9/22/2025

#include <iostream>
using namespace std;

void bigA();
void bigC();
void bigB();

// bigA
// Parses strings in the language generated by the rule:
// <A> -> a<A> | a
void bigA() {
    lex();
    switch (nextToken) {
        // case for recursive use a<A>
        case A: case a:                             bigA(); break;
        // case for next step of <S> -> <A><C><B>
        case C: case c:                             bigC(); break;
        // if the file ends here go back to main
        case ENDFILE:                                      return;
        default:   errMsg("A, a, or c expected, found " + lexeme);
    }
}

// bigC
// Parses strings in the language generated by the rule:
// <C> -> c
void bigC() {
    lex();
    // case for next step of <S> -> <A><C><B>
    if (nextToken == B || nextToken == b)       bigB();
    else errMsg("c, B, or b expected, found " + lexeme);
}

// bigB
// Parses strings in the language generated by the rule:
// <B> -> b<B> | b
void bigB() {
    lex();
    switch (nextToken) {
        // case for if one <S> ends on b and goes to next line
        case A: case a:                         bigA(); break;
        // case for recursive use b<B>
        case B: case b:                         bigB(); break;
        // if the file ends here go back to main
        case ENDFILE:                                  return;
        default:   errMsg("B or b expected, found " + lexeme);
    }
}